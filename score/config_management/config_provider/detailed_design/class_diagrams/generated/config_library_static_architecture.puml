@startuml

!startsub ConfigProviderLibrary

' Submodule: Logger
package mw::log <<frame>> {
class Logger {
}

}
' Submodule: MemoryResource
class score::cpp::pmr::memory_resource{
+ score::cpp::pmr::get_default_resource() : score::cpp::pmr::memory_resource*
}
' Submodule: ProxyNeedsFactory
package mw::service::factory <<frame>> {
class ProxyNeedsFactory<typename ProxyNeeds> <<template>>{
+ template<typename ...Strategy> Create<Strategy ...>(): ProxyNeeds
}
}
' Submodule: ProxyNeeds
package mw::service <<frame>> {
class ProxyNeeds<typename... ProxySpec> <<template>> {
}
}
' Submodule: AdaptiveImmediateInstantiationStrategy
package mw::service <<frame>> {
class AdaptiveImmediateInstantiationStrategy<template <typename ProxyBase, \n\
typename ProxyImpl, \n\
typename AraProxy, \n\
typename PortIdentifier = void>> {
}
}
' Submodule: ConfigProviderFactory
namespace score::platform::config_provider {
class ConfigProviderFactory {
+ Create(\n\
token : score::cpp::stop_token,\n\
timeout : std::chrono::milliseconds,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token ,\n\
timeout : std::chrono::milliseconds ,\n\
memory_resource : score::cpp::pmr::memory_resource* const ,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
+ Create(\n\
token : score::cpp::stop_token,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
callback : IsAvailableNotificationCallback&&) : score::cpp::pmr::unique_ptr<ConfigProvider>
--
- logger_ : mw::log::Logger&
--
Responsibility: This class is responsible to create ConfigProvider class
}
}
' Submodule: ParameterSet
namespace score::config_management::config_daemon::data_model {
class ParameterSet {
+ ParameterSet(json_writer : std::unique_ptr<json::IJsonWriter>)
+ GetParameterSetAsString() : Result<score::cpp::pmr::string>
+ Add(parameter_name : const score::cpp::string_view, parameter_value : json::Any&&) : ResultBlank
+ Update(parameters : json::Object&&) : ResultBlank
+ SetCalibratable(is_calibratable : const bool) : void
+ SetQualifier(qualifier : const score::config_management::config_daemon::ParameterSetQualifier) : void
+ GetQualifier() : score::config_management::config_daemon::ParameterSetQualifier
+ GetParameter(parameter_name : const score::cpp::string_view) : Result<json::Any>
--
- data_ : std::unordered_map<score::cpp::pmr::string, Parameter>
- json_writer_ : std::unique_ptr<json::IJsonWriter>
- qualifier_ : score::config_management::config_daemon::ParameterSetQualifier
- is_calibratable_ : bool
--
Responsibility: This class encapsulates the idea of ParameterSet in detailed design
}
ParameterSet o-down- Parameter
}
ParameterSet o-down- score::config_management::config_daemon::ParameterSetQualifier
' Submodule: ParameterSetQualifier
namespace score::config_management::config_daemon {
enum ParameterSetQualifier {
kUnqualified
kQualified
kDefault
kModified
}
}
' Submodule: ConfigProviderError
namespace score::platform::config_provider {
enum ConfigProviderError {
kParsingFailed
kObjectCastingError
kParameterNotFound
kValueCastingError
kValueNotFound
kProxyNotReady
kProxyAccessTimeout
kProxyReturnedNoResult
kEmptyCallbackProvided
kCallbackAlreadySet
kMethodNotSupported
kFailedToSubscribe
kParameterSetNotFound
}
}
' Submodule: InitialQualifierState
namespace score::platform::config_provider {
enum InitialQualifierState {
kUndefined,
kInProgress,
kDefault,
kQualifying,
kUnqualified,
kQualified
}
}

package "ConfigProvider" <<frame>> {
' Submodule: ConfigProvider
namespace score::platform::config_provider {
abstract class ConfigProvider {
+ {abstract} GetParameterSet(\n\
set_name : const score::cpp::string_view) : Result<std::shared_ptr<const ParameterSet>>
+ {abstract} GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::optional<std::chrono::milliseconds>) : Result<std::shared_ptr<const ParameterSet>>
+ {abstract} GetParameterSetsByNameList(\n\
set_names : const score::cpp::pmr::vector<score::cpp::string_view>&,\n\
timeout : const std::optional<std::chrono::milliseconds>) : ParameterSetMap
+ {abstract} OnChangedInitialQualifierState(callback : InitialQualifierStateNotifierCallbackType&&) : ResultBlank
+ {abstract} OnChangedParameterSet(\n\
set_name : const std::string&,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ {abstract} OnChangedParameterSetCbk(\n\
set_name : std::string_view,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ {abstract} GetInitialQualifierState(\n\
timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
+ {abstract} WaitUntilConnected(\n\
timeout : const std::chrono::milliseconds,\n\
stop_token : const score::cpp::stop_token&) : bool
+ {abstract} CheckParameterSetUpdates() : ResultBlank
+ {abstract} GetCachedParameterSetsCount() : std::size_t
+ {abstract} GetInitialQualifierState() : InitialQualifierState
+ {abstract} GetInitialQualifierState(\n\
timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
--
Responsibility: This class is repsonsible for providing ParameterSet's and InitialQualifierState
}
}
' Submodule: ConfigProviderImpl
namespace score::platform::config_provider {
class ConfigProviderImpl {
+ GetParameterSet(\n\
set_name : const score::cpp::string_view) : Result<std::shared_ptr<const ParameterSet>>
+ GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::optional<std::chrono::milliseconds>) : Result<std::shared_ptr<const ParameterSet>>
+ GetParameterSetsByNameList(\n\
set_names : const score::cpp::pmr::vector<score::cpp::string_view>&,\n\
timeout : const std::optional<std::chrono::milliseconds>) : ParameterSetMap
+ OnChangedInitialQualifierState(callback : InitialQualifierStateNotifierCallbackType&&) : ResultBlank
+ OnChangedParameterSet(\n\
set_name : const std::string&,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ OnChangedParameterSetCbk(\n\
set_name : std::string_view,\n\
callback : OnChangedParameterSetCallback&&) : ResultBlank
+ GetInitialQualifierState(\n\
timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
+ CheckParameterSetUpdates() : ResultBlank
+ WaitUntilConnected(\n\
timeout : const std::chrono::milliseconds,\n\
stop_token : const score::cpp::stop_token&) : bool
+ GetCachedParameterSetsCount() : std::size_t
+ IsAwaitingProxyConnection() : bool
+ ConfigProviderImpl(\n\
internal_config_provider_future : mw::service::ProxyFuture<std::unique_ptr<IInternalConfigProvider>>,\n\
user_stop_token : score::cpp::stop_token,\n\
memory_resource : score::cpp::pmr::memory_resource* const,\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>,\n\
callback : IsAvailableNotificationCallback,\n\
persistency : score::cpp::pmr::unique_ptr<Persistency>)
+ GetInitialQualifierState() : InitialQualifierState
+ GetInitialQualifierState(timeout : const std::optional<std::chrono::milliseconds>) : InitialQualifierState
--
- logger_ : mw::log::Logger&
- parameter_sets_ : ParameterMap
- initial_qualifier_state_ : InitialQualifierState
- memory_resource_ : score::cpp::pmr::memory_resource* const
- internal_config_provider_ : std::shared_ptr<IInternalConfigProvider>
- mutex_ : std::mutex
- internal_config_provider_cv_ : concurrency::InterruptibleConditionalVariable
- persistency_ : score::cpp::pmr::unique_ptr<Persistency>
- client_handlers_ : ClientHandlersMap
- max_samples_limit_ : score::cpp::optional<std::size_t>
- polling_cycle_interval_ : score::cpp::optional<std::chrono::milliseconds>
- proxy_available_thread_ : score::cpp::optional<score::cpp::jthread>
- stop_callback_ : score::cpp::optional<score::cpp::stop_callback>
}
}

ConfigProvider <|-- ConfigProviderImpl

}

package "Persistency" <<frame>> {
' Submodule: PersistencyFactory
namespace score::platform::config_provider {
class PersistencyFactory {
+ Create(\n\
handle : const mw::core::Result<mw::per::SharedHandle<KeyValueStorageType>>&,\n\
memory_resource : score::cpp::pmr::memory_resource* const) : score::cpp::pmr::unique_ptr<Persistency>
--
- logger_ : mw::log::Logger&
--
Responsibility: This class is responsible to create Persistency class
}
}
' Submodule: Persistency
namespace score::platform::config_provider {
abstract class Persistency {
+ {abstract} ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ {abstract} CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>,\n\
sync_to_storage : bool) : void
+ {abstract} SyncToStorage() : void
--
Responsibilities: This class is responsible for reading and writing the ParameterSet to persistent storage
}
}
' Submodule: PersistencyImpl
namespace score::platform::config_provider {
class PersistencyImpl {
+ PersistencyImpl<KeyValueStorageType>(\n\
handle : score::cpp::pmr::unique_ptr<score::mw::storage::KeyValueStorage<KeyValueStorageType>>)
+ ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>,\n\
sync_to_storage : bool) : void
+ SyncToStorage() : void
--
- kvs_ : score::cpp::pmr::unique_ptr<score::mw::storage::KeyValueStorage<KeyValueStorageType>>
- logger_ : mw::log::Logger&
}
}

Persistency <|-- PersistencyImpl

' Submodule: PersistencyImpl
namespace score::platform::config_provider {
class PersistencyImpl {
+ ReadCachedParameterSets(\n\
cached_parameter_sets : ParameterMap&,\n\
memory_resource : score::cpp::pmr::memory_resource*,\n\
filesystem : std::unique_ptr<score::filesystem::Filesystem>) : void
+ CacheParameterSet(\n\
cached_parameter_sets : const ParameterMap&,\n\
param_set_key : const score::cpp::pmr::string,\n\
parameter_set : const std::shared_ptr<const ParameterSet>,\n\
sync_to_storage : bool) : void
+ SyncToStorage() : void
--
- logger_ : mw::log::Logger&
}
}

Persistency <|-- PersistencyImpl

' Submodule: PersistencyError
namespace score::platform::config_provider {
enum PersistencyError {
kDataNotFound
kUnableToSaveToPersistency
}
}
}

package "InternalConfigProvider_proxy" <<frame>> {
' Submodule: IInternalConfigProvider
namespace score::platform::config_provider {
abstract class IInternalConfigProvider {
+ {abstract} GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::chrono::milliseconds) : Result<json::Any>
+ {abstract} TrySubscribeToLastUpdatedParameterSetEvent(\n\
stop_token : const score::cpp::stop_token&,\n\
callback : OnChangedParameterSetCallback&&) : bool
+ {abstract} GetInitialQualifierState(\n\
timeout : const std::chrono::milliseconds) : InitialQualifierState
+ {abstract} StartParameterSetUpdatePollingRoutine(\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>) : void
+ {abstract} StopParameterSetUpdatePollingRoutine() : void
+ {abstract} CheckParameterSetUpdates() : void
--
Responsibilities: This class wraps communication with external service InternalConfigProvider
}
}
' Submodule: InternalConfigProvider
namespace score::platform::config_provider {
class InternalConfigProvider {
+ InternalConfigProvider(proxy : std::unique_ptr<AdaptiveProxy>)
+ GetParameterSet(\n\
set_name : const score::cpp::string_view,\n\
timeout : const std::chrono::milliseconds) : Result<json::Any>
+ TrySubscribeToLastUpdatedParameterSetEvent(\n\
stop_token : const score::cpp::stop_token&,\n\
callback : OnChangedParameterSetCallback&&) : bool
+ GetInitialQualifierState(timeout : const std::chrono::milliseconds) : InitialQualifierState
+ StartParameterSetUpdatePollingRoutine(\n\
max_samples_limit : score::cpp::optional<std::size_t>,\n\
polling_cycle_interval : score::cpp::optional<std::chrono::milliseconds>) : void
+ StopParameterSetUpdatePollingRoutine() : void
+ CheckParameterSetUpdates() : void
--
- logger_ : mw::log::Logger&
- proxy_ : std::unique_ptr<AdaptiveProxy>
- on_changed_parameter_set_callback_ : OnChangedParameterSetCallback
- is_available_notification_callback_ : IsAvailableNotificationCallback
- max_samples_limit_ : std::size_t
- polling_cycle_interval_ : std::chrono::milliseconds
- polling_routine_cv_ : concurrency::InterruptibleConditionalVariable
- last_updated_parameter_set_names_ : score::cpp::pmr::unordered_set<std::string>
- mutex_ : std::mutex
- polling_thread_ : score::cpp::optional<score::cpp::jthread>
}
}

IInternalConfigProvider <|-- InternalConfigProvider

}

/' Packages relationships '/

package "Persistency" <<Persistency>> {
Persistency <|-right- PersistencyImpl
Persistency <|-right- PersistencyImpl
PersistencyImpl <-down- PersistencyFactory : construct
PersistencyImpl <-down- PersistencyFactory : construct
class KeyValueStorage <<external>> #LightGray {
Responsibility: External mw::per key/value storage API used by PersistencyImpl
}
PersistencyImpl *-- KeyValueStorage : uses
}

package "InternalConfigProvider_proxy" <<InternalConfigProvider_proxy>> {
class Proxies{
using Proxies = mw::service::ProxyNeeds<IInternalConfigProvider>
--
Responsibility: Owns a single instance of InternalConfigProvider proxy.
}

class InternalConfigProviderProxy <<generated>> #Gray{
Responsibility: This is the generated proxy from mw::com.
}
InternalConfigProvider *-- InternalConfigProviderProxy
Proxies o-- IInternalConfigProvider
}

Adaptive_Application *-- ConfigProvider.ConfigProvider
Adaptive_Application -left-> PersistencyFactory : construct
Adaptive_Application --> ConfigProviderFactory : construct
ConfigProviderImpl <-right- ConfigProviderFactory : construct
Persistency.Persistency --* ConfigProviderImpl
ParameterSet <-up- ConfigProviderImpl : creates & returns
ConfigProviderImpl ..> ConfigProviderError : create
ConfigProviderImpl *-- IInternalConfigProvider
ConfigProviderFactory -down-> Proxies : construct
ConfigProviderFactory -up-> ProxyNeedsFactory : use Strategy: InternalConfigProviderStrategy ProxyNeeds: mw::service::Optional<IInternalConfigProvider>
ConfigProviderFactory --> ProxyNeeds
ConfigProviderFactory --> AdaptiveImmediateInstantiationStrategy
ConfigProviderFactory --> score::cpp::pmr::memory_resource : Use
ParameterSet o-- ParameterSetQualifier
ParameterSet ..> ConfigProviderError
ConfigProvider.ConfigProvider .up.> Logger : Use

note right of ParameterSet #LightSkyBlue
ConfigProviderImpl creates a ParameterSet as a business
object abstraction for a specific user application.

We use a shared_ptr, since the OnChange callback
will need to capture the ParameterSet map.
end note

note left of InternalConfigProviderProxy #LightSkyBlue
Following the Proxy-Pattern of mw::service
end note

@enduml
